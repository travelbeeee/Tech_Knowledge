# Trie

### 1) Trie 트라이

트라이는 문자열 탐색에 특화된 자료구조로 다음과 같은 특징이 있습니다.

- 트라이는 문자열의 집합을 표현하는 트리 자료 구조로 위의 그림과 같은 형태로 이루어져 있습니다. **트라이의 한 노드를 표현하는 객체는 자손 노드들을 가리키는 포인터 목록과, 이 노드가 종료 노드인지를 나타내는 불린 값 변수로 구성**됩니다.
- 자손 노드들을 가리키는 포인터 목록은 **입력에 등장할 수 있는 모든 문자에 각각 대응되는 원소를 갖는 고정 길이 배열**로 구현합니다.
- 루트에서 한 노드까지 내려가는 경로에서 만나는 글자들을 모으면 해당 노드에 대응되는 접두사를 얻을 수 있습니다. 따라서, 각 노드에 대응되는 문자열을 따로 저장할 필요가 없습니다.

문자열은 정수, 실수형 변수와 다르게 비교하는 데 최악의 경우 문자열의 길이에 비례하는 시간이 걸립니다. 따라서, 정수나 실수 키에 대해서는 잘 동작하는 탐색 자료 구조들도 문자열을 키로 사용할 때는 시간이 오래 걸릴 수 있습니다. 예를 들어, N개의 원소를 갖는 이진 검색 트리에서 원하는 원소를 찾으려면 O(logN)번의 비교를 해야 하지만, 문자열의 비교에서는 최대 문자열의 길이를 M이라고 하면 O(MlogN)이 최종 시간 복잡도가 됩니다. 

이런 문제를 해결하기 위해 자료구조 트라이(Trie)가 등장했습니다.

<br>

문자열 { Hello, Hell, Hall, Travel, Halo } 를 자료구조 트라이에서 저장하고 있는 그림입니다.

<img src="https://user-images.githubusercontent.com/59816811/105820360-d1221080-5ffc-11eb-8ae9-72d67e6aefe8.png" alt="trie01" width="500"/>

<br>

### 2) 코드구현 (C++)

```c++
struct Trie {
	bool finish;    //끝나는 지점을 표시해줌
	Trie* nextNode[26];    //26가지 알파벳에 대한 트라이 포인터 배열
	Trie() {
		finish = false;
		memset(nextNode, 0, sizeof(nextNode));
	}
	~Trie() {
		for (int i = 0; i < 26; i++)
			if (nextNode[i])
				delete nextNode[i];
	}

	void insert(const char* key) {
		if (*key == '\0')
			finish = true;    //문자열이 끝나는 지점일 경우 표시
		else {
			int next = *key - 'A';
			if (nextNode[next] == NULL)
				nextNode[next] = new Trie();    //탐색이 처음되는 지점일 경우 동적할당
			nextNode[next]->insert(key + 1);    //다음 문자 삽입
		}
		return;
	}

	Trie* find(const char* key) {
		if (*key == 0)
			return this;
		int next = *key - 'A';
		if (nextNode[next] == NULL) // 문자열에 없음.
			return NULL;
		return nextNode[next]->find(key + 1); // 다음 문자로 탐색을 진행
	}
};
```

대문자로만 입력된다고 가정하고 구현한 트라이입니다. 소문자 혹은 다른 문자들이 추가로 입력되는 경우라면 고정 길이 배열을 변경해줘야합니다.

<br>

### 3) 트라이 복잡도 계산

트라이에서 가장 중요한 연산은 find 함수와 insert 함수입니다.

이 함수들은 문자열의 길이만큼 재귀 호출을 수행하기 때문에, 두 함수의 시간 복잡도는 모두 문자열의 길이(M)에 비례합니다. 즉, 트라이에 포함된 다른 문자열의 개수(N)과는 상관이 없다는 것을 알 수 있습니다. 따라서 트라이는 빠른 속도가 필요한 검색 엔진이나 기타 문자열 처리 프로그램에서 자주 사용됩니다.

- **insert 함수 시간 복잡도 : O(M)**
- **find 함수 시간 복잡도 : O(M)**

<br>

### 4) 트라이 단점

트라이 자료구조는 문자열 검색에 있어서 시간을 굉장히 단축시키지만 **메모리를 많이 사용**해야만 합니다. 그 이유는 포인터 배열 때문입니다. 알파벳 소문자/대문자로 이루어진 문자열을 다룬다고 할 때 각 노드마다 52개의 포인터를 가지고 있어야하므로 굉장히 많은 메모리를 사용하게 됩니다.