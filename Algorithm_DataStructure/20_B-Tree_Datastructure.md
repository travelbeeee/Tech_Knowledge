# B-Tree

 B-Tree는 이진트리에서 발전되어 **모든 리프노드들이 같은 레벨을 가질 수 있도록** 자동으로 밸런스를 맞추는 트리입니다. 또한, 이진 탐색 트리처럼 정렬된 순서를 보장하고 이진 트리와 다르게 M개의 자식을 가질 수 있고, M차 B-Tree라고 부릅니다.

- 노드는 자식을 최소한 (M / 2)개 가지고 있어야합니다.
- 노드는 (M - 1)개 부터 (M / 2 - 1) 개의 키가 포함 될 수 있습니다.
  -  최소한 (M / 2 - 1) 개의 키를 가지고 있어야합니다.
- 노드의 키가 K개 라면 자식의 수는 K + 1개 입니다.
- 노드의 키는 반드시 정렬된 상태여야 합니다.
- 노드의 키를 기준으로 왼쪽 서브 트리는 더 작은 값으로 오른쪽 서브 트리는 더 큰 값으로 이루어져있어야합니다.

 <br>

### Key 검색 과정

![B트리 기본 형태](https://user-images.githubusercontent.com/59816811/135752240-00b6b2a1-a6fe-4714-a1ef-805d3d22f940.png)

-  루트노드에서 시작하여 하향식으로 검색을 수행합니다. 검색하고자 하는 Key를 K라고 했을 때, 루트 노드에서 시작하여 Key들을 순회하면서 검사합니다.
  - 만일 K와 같은 Key를 찾았다면 검색을 종료합니다.
  - 검색하는 값과 Key들의 대소 관계를 비교합니다. 어떠한 Key 사이에 K가 들어간다면 해당 Key들 사이의 자식 노드로 내려갑니다.
- 리프노드에 도달할 때까지 반복합니다.

<br>

### Key 삽입 과정

 key를 삽입하기 위해서는 **1. 요소 삽입에 적절한 리프 노드를 검색**하고, **2. 필요한 경우 노드를 분할**해야 합니다. 리프노드 검색은 하향식이지만 노드 분할의 과정은 **상향식**으로 이루어진다고 볼 수 있습니다. 삽입하고자 하는 값을 *k*로 하였을 때 삽입 과정입니다.

- 트리가 비어있으면 루트 노드를 할당하고 *k*를 삽입합니다. 만일 루트노드가 가득 찼다면, **노드를 분할**하고 리프노드가 생성됩니다.
- 이후부터는 삽입하기에 적절한 리프노드를 찾아 *k*를 삽입합니다. 삽입위치는 노드의 key값과 *k*값을 **검색 연산과 동일한 방법으로** 비교하면서 찾습니다.

<img width="1312" alt="btree_6" src="https://user-images.githubusercontent.com/59816811/135753530-115569b7-2290-4a6d-baff-7d53a71e1c8d.png">

<br>

### Key 삭제 과정

요소를 삭제하기 위해선 **1. 삭제할 키가 있는 노드 검색, 2. 키 삭제, 3. 필요한 경우, 트리 균형 조정**을 해야합니다.

<img width="858" alt="btree_7" src="https://user-images.githubusercontent.com/59816811/135753666-59fa645a-851f-4678-a6e0-6ae54c80ad54.png">

<img width="1636" alt="btree_8" src="https://user-images.githubusercontent.com/59816811/135753679-7e19bada-1257-4214-a5bb-2b094e41be57.png">

<img width="851" alt="btree_9" src="https://user-images.githubusercontent.com/59816811/135753681-f6fa79dc-1abc-4eeb-b19a-d0ae0d9bbd82.png">