# Deadlock

### 1) Deadlock

 데드락은 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 말합니다. 즉, **둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황**을 일컫습니다.

<br>

### 2) Deadlock 발생조건

데드락이 발생하기 위한 조건은 4가지가 있습니다. 이 4가지 조건을 만족하는 상황에서는 `Deadlock`이 발생할 수 있습니다.

- Mutual Exclusion ( 상호 배제 )
  - 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
- Hold and Wait ( 점유 대기 )
  - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
- No Preemption ( 비선점 )
  - 이미 할당된 자원을 강제로 빼앗을 수 없다(비선점)
- Circular Wait ( 순환 대기 )
  - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

<br>

### 3) Deadlock 해결방법

 `Deadlock`은 크게 3가지 방법을 해결할 수 있습니다.

- Prevention
  - 데드락이 발생될 가능성을 예방하는 방법입니다.
- Avoidance
  - 데드락이 가능성을 검사하고 가능성이 없는 경우에만 자원을 할당하는 방법입니다.
- Detection and Recovery
  - 데드락이 발생하면 프로세스를 하나씩 죽이거나 모두 죽이는 등 데드락이 발생하면 대처하는 방법입니다.

<br>

### 4) Deadlock Prevention

 `Prevention` 방법은 데드락이 발생할 가능성을 애초에 없애는 방법입니다. 즉, `Deadlock` 발생 4가지 조건 중 하나라도 발생하지 않게 하는 기법입니다.

- Mutual Exclusion 조건 방지
  - 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 합니다. 추후에 `Race condition` 상태가 발생할 수 있습니다.
- Hold and Wait 조건 방지
  - 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 합니다. 당장 사용하지 않는 자원도 모두 할당받으므로 효율성에 문제가 있습니다. 또, 프로세스가 실행 전부터 필요한 모든 자원을 파악할 수 없다는 문제가 있습니다.
- No Preemption 조건 방지
  - 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 합니다.
- Circular Wait 조건 방지
  - 자원을 순환 형태로 대기하지 않도록 일정한 방향으로만 자원을 요구할 수 있도록 합니다.

이러한 조건을 방지해서 데드락을 예방하는 방법은 **시스템의 처리량이나 효율성을 떨어트리는 단점**이 발생할 수 있어서 사용하지 않습니다.

<br>

### 5) Deadlock Avoidance

 `Avoidance` 방법은 데드락이 발생할 가능성이 있다면 자원을 할당하지 않고, 데드락 발생할 가능성이 없을 때만 자원을 할당하는 방법입니다. 대표적인 알고리즘으로는 다익스트라가 제안한 `Banker's Algorithm`이 있습니다.

 `Banker's Algorithm`은 프로세스가 요청한 자원을 할당한 후에도 `Safe State`를 유지할 수 있으면 자원을 할당해주고, 아니라면 자원을 할당하지 않습니다. 이를 위해 각 프로세스들이 최대 얼마나 자원을 요청할지(MAX), 현재 얼마만큼 자원을 할당받았는지(Allocated), 시스템이 얼마나 자원을 보유하고 있는지(Available) 정보를 알고 있어야 합니다.

 따라서, **미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약조건**이 많고, 그에 따른 자원 이용도 하락 등 단점도 존재합니다

- Safe State
  - 시스템의 프로세스들이 요청하는 모든 자원을 차례로 모두에게 할당해 줄 수 있다면 **안정 상태**(safe state)에 있다고 말합니다. 이처럼 특정한 순서로  프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 **데드락이 발생하지 않는 순서를 찾을 수 있다면**, 그것을 **안전 순서**(safe sequence)라고 부릅니다.
- UnSafe State
  - 불안정 상태로 안정 상태가 아닌 상황을 말합니다. 불안정 상태에서는 데드락이 발생할 수 있습니다.

<br>

### 6) Deadlock Detection and Recovery

 `Detection and Recovery` 방법은 데드락이 발생했는지 탐지하고, 발생했다면 데드락을 회복하는 전략입니다.

- 탐지 기법

  - Allocation, Request, Available 등으로 시스템에 **데드락이 발생했는지 여부를 탐색**합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악합니다.
  - 이 외에도 **자원 할당 그래프를 통해 탐지**하는 방법도 있습니다.

- 회복 기법

  데드락을 탐지 기법을 통해 발견했다면, **`순환 대기`에서 벗어나 데드락으로부터 회복하기 위한 방법**을 사용합니다.

  - 프로세스 중단시키기
    - **교착 상태에 빠진 모든 프로세스를 중단시키는 방법** : 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
    - **프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법** : 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
  - 자원 선점하기
    - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법

