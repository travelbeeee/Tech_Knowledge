# Process Scheduling

 프로세스 스케쥴링 전략에 대해서 정리해보겠습니다.

<br>

### 1) FIFO (First In First Out ) /  FCFS ( First Come First Served )

 FIFO, FCFS 알고리즘은 이름 그대로 먼저 들어온 프로세스부터 처리하는 스케쥴링 전략입니다.

- 장점
  - 스케쥴링 이해와 구현이 단순
  - 준비 큐에 있는 모든 프로세스가 실행되므로 공정한 스케쥴링
  - CPU가 지속적으로 프로세스를 수행하여 처리율이 높음
- 단점
  - 장기 실행 프로세스가 있으면 뒤에 있는 모든 프로세스를 대기시켜 평균 대기 시간이 길어짐
    - 이를 Convey Effect 라고 부름

<br>

### 2) SJF ( Shortest Job First Scheduling )

 SJF는 이름 그대로 CPU를 적게 사용하는 프로세스부터 처리하는 스케쥴링 전략입니다. `Preemptive`한 방식과 `Non Preemptive`한 방식에서 차이가 있기 때문에 2가지 상황을 나눠서 정리하겠습니다.

- Preemptive ( Shortest Remaining Time First )
  - 선점형 방식으로 현재 진행 중인 프로세스의 남은 CPU 사용 시간보다 더 짧은 프로세스가 대기 큐에 들어오면 더 짧은 프로세스가 CPU를 점유하는 전략입니다.
- Non Preemptive ( Shortest Job First )
  - 비선점형 방식으로 현재 가장 사용 시간이 짧은 프로세스를 진행시키고, 해당 프로세스가 CPU를 모두 사용한 후에 다시 대기 중인 프로세스 중에 가장 짧은 프로세스를 실행시키는 전략입니다.

 SJF 방식은 FIFO, FCFS와 달리 평균 대기 시간이 가장 짧은 전략입니다. 다만, 프로세스의 CPU 사용 시간을 예측해야된다는 문제가 있고, 긴 프로세스는 계속해서 실행이 되지 않을 수 있다는 문제가 남아있습니다.

- 장점
  - 평균 대기 시간이 가장 짧음
- 단점
  - 프로세스의 CPU 사용 시간을 예측해야된다. 따라서, 과거에 해당 프로세스가 이용한 CPU 시간으로 사용 시간을 예측해야된다.
  - 긴 프로세스는 실행되지 않는 `Starvation` 문제가 발생한다.

<br>

### 3)  Priority

 우선순위 전략은 이름 그대로 우선 순위가 높은 프로세스부터 실행시키는 전략입니다. 먼저 온 프로세스에게 높은 우선 순위를 부여하면 `FIFO`, 짧은 프로세스에게 높은 우선 순위를 부여하면 `SJF`가 될 수 있습니다.

  우선 순위는 내부적으로 정의될 수도 있고, 외부적으로 정의될 수도 있습니다. OS가 여러 가지를 종합적으로 사용해 내부적으로 우선 순위를 정할 수도 있고, 우리가 프로세스의 우선 순위를 외부에서 설정해줄 수도 있습니다.

 `SJF`와 마찬가지로 `Preemptive` 와 `Non Preemptive` 두 가지 방식이 있고, 우선 순위가 낮은 프로세스는 계속 실행되지 않는 `Starvation` 문제가 발생합니다. 

 `Starvation` 문제를 해결하기 위해 일정 시간 대기 중인 프로세스는 우선 순위를 올려주는 `Aging` 기법이 등장했습니다.

<br>

### 4) RR ( Round Robin )

  라운드 로빈 전략은 `time quantum` 단위로 프로세스에게 CPU를 할당하는 전략입니다. `time quantum`이 굉장히 길다면 `FIFO` 전략과 비슷하게 동작하고, 짧다면 컨텍스트 스위칭이 자주 발생해 오버헤드가 크다는 단점이 있습니다.

- 장점
  - 모든 프로세스가 `FAIR`하게 실행된다.
  - `Starvation` 현상이 없다.
- 단점
  - `Context Switching`으로 인한 오버헤드가 있다.
  - `time quantum`의 크기에 따라 성능이 달라진다.

<br>

### 5) Multilevel Queue

 다단계 큐 전략은 여러 개의 큐에 다양한 스케쥴링 전략을 사용하는 기법입니다. 어떤 프로세스냐에 따라서 여러 종류의 그룹으로 나누고 그룹마다 대기 중인 큐가 존재하는 전략입니다. 

 제일 대표적인 방법은 큐마다 `RR` 전략을 가지고 있고, 우선 순위가 높은 큐는 짧은 `time quantum`을 부여하고, 우선 순위가 낮은 큐는 긴 `time quantum`을 부여하는 전략입니다. 사용자와 interactive하게 동작하는 프로세스들은 높은 우선 순위를 부여해서 빠르게 일을 수행하고, background에서 돌아가는 프로세스들은 낮은 우선 순위를 부여해서 다른 일들이 다 끝나고 수행하도록 합니다.

- 장점
  - 큐마다 다양한 스케쥴링 전략 사용 가능
- 단점
  - 프로세스가 한 번 큐에 속하게 되면 다른 큐로 이동이 불가능해 `Starvation` 문제가 발생할 수 있다.

<br>

### 6) Multilevel Feedback Queue

 다단계 큐 전략과 비슷하게 여러 개의 큐를 사용하고 우선 순위가 더 높은 큐에 있는 프로세스부터 CPU를 점유하고 동작하게 됩니다.

 다만, 동작 방식이 조금 차이가 있습니다. 먼저, 모든 프로세스들은 가장 높은 우선 순위의 큐에서 대기하게 됩니다. `RR` 전략으로 해당 큐에서 `time quantum`을 다 사용하고 아직 수행해야 될 일이 남아있다면 한 단계 우선순위가 낮은 큐로 내려갑니다.

 이런 식으로 오래 걸리는 작업들은 우선 순위가 점점 낮아지게 되고, 대화형 작업과 같은 짧은 실행 시간을 가지고 빨리 반응이 필요한 작업들은 우선 순위가 높은 큐에서 작업이 완료되게 됩니다.

 문제점으로는 여전히 `Starvation` 문제가 남아있습니다.

