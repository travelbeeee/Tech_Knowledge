# Race Condition, Deadlock

### 1) Race Condition, Critical Section

 프로세스 혹은 스레드들이 공유된 자원에 접근하는데 접근 순서에 따라 결과가 달라지는 상황을 `Race condition` 이라고 합니다. `Race condition`을 해결하기 위해서는 프로세스 혹은 스레드의 수행 시점을 조절해야합니다. 이를, `Synchronization` 이라고 합니다. 

 이때, 공유된 자원에서 문제가 발생하지 않게 하나의 스레드만 접근하도록 보장해줘야되는 구역을 `Critical section`이라고 합니다. `Critial Section`에 하나의 스레드만 접근하도록 보장해준다면 `Race condition` 문제를 해결할 수 있고, 이를 위한 방법은 `Lock`입니다. `Critical Section`에 접근하기 전에 `Lock`을 걸고, 접근이 끝나면 `UnLock`을 통해 다른 스레드에서 접근가능하게 만들어주는 방법을 통해 `Race condition` 상황을 해결할 수 있습니다.

> [예시] 은행 입출력 문제
>
> 1) A쓰레드에서 계좌 접근 --> 계좌 잔액 100만원 임을 읽음.
>
> 2) B쓰레드가 끼어들어 동일 계좌에 접근 --> 계좌 잔액 100만원 임을 읽음.
>
> 3) 다시 A쓰레드가 이어서 수행하며 10만원을 인출해감 --> 90만원이라고 잔액 저장
>
> 4) B쓰레드가 이어서 수행하며 10만원을 인출해감 --> 90만원이라고 잔액 저장
>
> 이처럼, 10만원 씩 두 번 인출이 일어났지만, 10만원만 계좌 잔액에서 빠져나가는 문제가 생길 수 있습니다.

<br>

### 2) Race Condition 해결조건

 `Race Condition`은 아래의 3가지 조건을 만족하면 문제가 발생하지 않습니다.

- **Mutual exclusion**
  - 두 개 이상의 프로세스들이 동시에 임계 영역에 있어서는 안 된다.
- **Progress**
  - 임계 구역 바깥에 있는 프로세스가 다른 프로세스의 임계 구역 진입을 막아서는 안 된다.
- **Bounded Waiting**
  - 어떤 프로세스도 임계 구역으로 들어가는 것이 무한정 연기되어서는 안된다.

<br>

### 3) 데커 알고리즘 

 데커의 알고리즘은 두 프로세스 또는 스레드가 하나의 자원을 혼란 없이 공유할 수 있는 병행 프로그래밍 알고리즘입니다. 원자적 명령이 없는 경우에도 사용할 수 있으며, `Busy waiting` 알고리즘에 속해 성능 문제로 사용하지 않는 알고리즘입니다.

```java
f0 ← false
f1 ← false
turn ← 0   // or 1

 p0:                                 p1:
     f0 ← true                         f1 ← true
     while f1 {                          while f0 {
         if turn ≠ 0 {                      if turn ≠ 1 {
             f0 ← false                         f1 ← false
             while turn ≠ 0 {                  while turn ≠ 1 {
             }                                   }
             f0 ← true                          f1 ← true
         }                                   }
     }                                    }

    // 임계 구역                          // 임계 구역 
    ...                                   ...
    // 나머지 구역                        // 나머지 구역
   turn ← 1                             turn ← 0
   f0 ← false                           f1 ← false
```

<br>

### 4) 피터슨 알고리즘

 피터슨 알고리즘도 두 프로세스 또는 스레드가 하나의 자원을 혼란 없이 공유할 수 있는 병행 프로그래밍 알고리즘입니다. 원자적 명령이 없는 경우에도 사용할 수 있으며, `Busy waiting` 알고리즘에 속해 성능 문제로 사용하지 않는 알고리즘입니다.

```java
do{
	flag[i] = true;
	turn = j;
	
	while(flag[j] && turn == j); // busy waiting
	
	//-- critical section --
	
	flag[i] = false;
	
	//-- remainder section --
}while(true)
```

<br>

### 5) Atomic 명령어

 락 변수 한개를 사용해 락이 안 걸려있으면 락을 걸고 임계영역에 들어가고 임계영역에 나오면 락을 해제하면 될 것 같지만, 고급 언어의 읽고 쓰는 연산은 여러 개의 CPU instruction으로 이루어져 있기 때문에 중간에 interrupt가 발생할 수 있다는 문제가 있습니다. 따라서, 하드웨어적 instruction을 사용해 atomic하게 락을 거는 방법을 이용할 수 있습니다.

<br>

### 6) 뮤텍스

 뮤텍스는 자원에 대한 접근을 동기화하기 위해 사용되는 상호배제 기술입니다. 즉, 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 방법입니다. 프로그램이 시작될 때 고유한 이름으로 생성되고, Locking 메커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역(Critical Section)에 들어올 수 있습니다. 그리고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있습니다.

```java
lock(mutex); 

// -- Critical Section --

unlock(mutex);
```

<br>

### 7) 세마포어

 세마포어는 Signaling 메커니즘이라는 점에서 뮤텍스와 다릅니다. 세마포어는 락을 걸지 않은 쓰레드도 Signal을 보내 락을 해제할 수 있다는 점에서, wait 함수를 호출한 쓰레드만이 signal 함수를 호출할 수 있는 뮤텍스와 다릅니다. 세마포어는 동기화를 위해 wait와 signal이라는 2개의 atomic operations를 사용합니다. Wait() 연산은 P로 임계 구역에 들어가기 전에 실행되고 세마포어의 카운트를 1 줄입니다. 세마포어의 카운트가 0보다 작거나 같다면 임계 구역에 들어가지 못하고 락이 실행됩니다. Signal() 연산은 V로 임계 구역에서 나오면서 실행되고 세마포어의 카운트를 1 늘려줍니다.

```java
 P(S) {
     while S <=0; // 아무것도 하지 않음 (반복문)
     S--;
 }

 V(S) {
     S++;
 }
```

 세마포어는 크게 Counting Semaphores, Binary Semaphore 2종류가 있다. 카운팅 세마포어는 세마포어의 카운트가 양의 정수값을 가지며, 설정한 값만큼 쓰레드를 허용하고 그 이상의 쓰레드가 자원에 접근하면 락이 실행된다. 바이너리 세마포어는 세마포어의 카운트가 1이며 Mutex처럼 사용될 수 있다.

 세마포어의 주된 단점은 이들이 모두 바쁜 대기(busy waiting)를 요구한다는 점입니다. 이를 개선하기 위해 세마포어를 음수 값을 가질 수 있게 개선하여 대기 중인 프로세스의 수도 나타내고, 리스트에 대기 프로세스를 저장하고 대기 중인 프로세스는 CPU를 반환해 다른 프로세스가 동작하도록 하는 방식이 등장했습니다.

<br>

### 8) 모니터

 모니터는 좀 더 고수준의 동기화 기능을 제공하는 도구입니다. 모니터는 **공유 자원 + 공유 자원 접근함수**로 이루어져 있고, 2개의 큐를 가지고 있다. 각각 **mutual exclusion(상호배타) queue, conditional synchronization(조건동기) queue**이다.

- 상호배타 큐는 말그대로 공유 자원에 하나의 프로세스만 진입하도록 하기 위한 큐이다.
  - 다른 프로세스가 모니터를 점유하고 있으면 상호배타 큐에서 대기하게 된다.
- 모니터 안에서 공유 자원을 사용하던 도중 `wait()` 을 통해 진입하는 큐이다. 
  - 모니터 안에서 공유 자원을 사용하는 프로세스가 `notify()` 를 호출하면 `wait()`을 통해 조건동기 큐에서 대기하고 있던 프로세스가 모니터를 이어서 사용하게 된다.
- 자바에서 `Synchronized` 키워드는 모니터를 이용해서 구현되어있다.

