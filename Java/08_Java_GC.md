# Java_Garbage Collection

자바 `Garbage Collection`에 대해서 정리해보겠습니다.

<br>

### 1) Garbage Collection 이란

 프로그램을 개발 하다 보면 유효하지 않은 메모리인 가바지(Garbage)가 발생하게 된다. 자바에서는 개발자가 메모리를 직접 해제해주지 않아도 JVM의 가비지 컬렉터가 불필요한 메모리를 알아서 정리해준다. 대신 Java에서 명시적으로 불필요한 데이터를 표현하기 위해 일반적으로 null을 선언해준다.

 Java에서는 가비지 컬렉터가 주기적으로 검사하여 사용이 되지 않는 메모리를 청소해준다.

 모든 자바 애플리케이션은 `JVM` 환경에서 작동하므로 `Garbage Collection` 은 자바 애플리케이션의 응답 시간가 성능에 밀접한 관계를 가지게 됩니다.

 자바의 가비지 컬렉터는 그 동작 방식에 따라 매우 다양한 종류가 있지만 공통적으로 다음 2가지 작업을 수행한다.

- Heap 내의 객체 중에서 Garbage를 찾아낸다.
- 찾아낸 Garbage를 처리해서 Heap 의 메모리를 회수한다.

> 자바에서도 System.gc() 를 이용해 가비지 컬렉션을 호출할 수 있지만, 시스템의 성능에 매우 안좋은 영향을 끼친다.

<br>

### 2)  `Young(Minor GC)` , `Old(Major GC)` 영역

자바 `Garbage Collection` 은 2가지를 전제로 설계되었습니다.

- 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)이 된다.
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

즉, 객체는 대부분 일회성이며 메모리에 오랫동안 남아있는 경우는 드물다! 를 전제로 만들어졌습니다.

그렇기 때문에, 객체의 생존 기간에 따라 물리적인 `Heap` 영역을 `Young`, `Old` 2가지 영역으로 설계했습니다.

> 초기에는 `Perm` 영역도 존재했으나, Java8부터 제거되었습니다.

![img](https://user-images.githubusercontent.com/59816811/135704340-48ecc01a-3cbc-4f9e-85da-a0db35f6d98f.png)

- `Young` 영역
  - 새롭게 생성된 객체가 할당되는 영역
  - 대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 대부분의 객체는 `Young` 영역에 생성되었다가 사라집니다.
  - `Young` 영역에 대한 가비지 컬렉션을 `Minor GC`라고 부릅니다.
- `Old` 영역
  - `Young`영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
  - 복사되는 과정에서 대부분 `Young` 영역보다 크게 할당되며, 크기가 큰 만큼 `GC`가 `Young`영역보다 적게 발생한다.
  - `Old` 영역에 대한 가비지 컬렉션을 `Major GC` 라고 부릅니다.

<br>

그러면, `Old` 영역에서 `Young` 영역의 객체를 참조하면 어떻게 될까?? `Old` 영역에서 참조하고 있는 `Young` 영역 객체가 GC 대상이 되면 안되므로 이를 위해 `Old` 영역에는 512바이트의 덩어리로 되어 있는 `Card Table` 이 존재합니다.

![helloworld-1329-2](https://user-images.githubusercontent.com/59816811/135704440-fa1df0a7-178a-4c94-a1d8-70c545f04cec.png)

카드 테이블을 이용해 `Old` 영역에서 참조하고 있는 `Young` 영역 객체를 관리하고 있습니다. 따라서, `Minor GC` 는 카드 테이블만 확인해 `Old` 영역에서 참조하고 있지 않다면 GC가 가능합니다. 즉, `Minor GC`는 `Stop-the-world` 과정 없이 카드 테이블을 이용해 가능합니다.

<br>

### 3) Young (Minor GC)

`Young` 영역은 또 내부적으로 3개의 영역으로 나뉜다.

- Eden 영역 
- Survivor 영역 ( 2개 )

영역의 처리 절차는 다음과 같다.

- 새로 생선한 대부분의 객체는 `Eden` 영역에 위치한다.
- `Eden` 영역에서 GC가 한 번 발생한 후 살아남은 객체는 `Survivor` 영역 중 하나로 이동한다.
- `Eden` 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 `Survivor` 영역으로 객체가 계속 쌓인다.
- 하나의 `Survivor` 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 `Survivor` 영역으로 이동한다. 그리고 가득 찬 `Survivor` 영역을 비웁니다.
- 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 `Old` 영역으로 이동하게 된다.

![helloworld-1329-3](https://user-images.githubusercontent.com/59816811/135704781-1d9aa15c-1ebf-43aa-b06b-52a876cc7d68.png)

> HotSpot VM에서는 보다 빠른 메모리 할당을 위해서 두 가지 기술을 사용한다. 하나는 bump-the-pointer라는 기술이며, 다른 하나는 TLABs(Thread-Local Allocation Buffers)라는 기술이다.
>
> bump-the-pointer는 Eden 영역에 할당된 마지막 객체를 추적한다. 마지막 객체는 Eden 영역의 맨 위(top)에 있다. 그리고 그 다음에 생성되는 객체가 있으면, 해당 객체의 크기가 Eden 영역에 넣기 적당한지만 확인한다. 만약 해당 객체의 크기가 적당하다고 판정되면 Eden 영역에 넣게 되고, 새로 생성된 객체가 맨 위에 있게 된다. 따라서, 새로운 객체를 생성할 때 마지막에 추가된 객체만 점검하면 되므로 매우 빠르게 메모리 할당이 이루어진다.
>
> 그러나 멀티 스레드 환경을 고려하면 이야기가 달라진다. Thread-Safe하기 위해서 만약 여러 스레드에서 사용하는 객체를 Eden 영역에 저장하려면 락(lock)이 발생할 수 밖에 없고, lock-contention 때문에 성능은 매우 떨어지게 될 것이다. HotSpot VM에서 이를 해결한 것이 TLABs이다.
>
> 각각의 스레드가 각각의 몫에 해당하는 Eden 영역의 작은 덩어리를 가질 수 있도록 하는 것이다. 각 쓰레드에는 자기가 갖고 있는 TLAB에만 접근할 수 있기 때문에, bump-the-pointer라는 기술을 사용하더라도 아무런 락이 없이 메모리 할당이 가능하다.

<br>

### 4)  Old (Major GC)

`Young` 영역에서 오래 살아남은 객체는 `Old` 영역으로 Promotion 된다. 따라서, `Major GC`는 객체들이 계속 Promotion되어 `Old` 영역의 메모리가 부족해지면 발생하게 된다. `Youn`g 영역은 일반적으로 `Old` 영역보다 크키가 작기 때문에 GC가 보통 0.5초에서 1초 사이에 끝난다. 그렇기 때문에 `Minor GC`는 애플리케이션에 크게 영향을 주지 않는다. 하지만 `Old` 영역은 `Young` 영역보다 크며 `Young` 영역을 참조할 수도 있다. 그렇기 때문에 `Major GC`는 일반적으로 `Minor GC`보다 시간이 오래걸리며, 10배 이상의 시간을 사용한다.

<br>

##### Stop The World

 `Stop The World`는 가비지 컬렉션을 실행하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업이다. `Major GC`가 실행될 때는 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되고, GC가 완료되면 작업이 재개된다. 당연히 모든 쓰레드들의 작업이 중단되면 애플리케이션이 멈추기 때문에, GC의 성능 개선을 위해 튜닝을 한다고 하면 보통 stop-the-world의 시간을 줄이는 작업을 하는 것이다. 또한 JVM에서도 이러한 문제를 해결하기 위해 다양한 실행 옵션을 제공하고 있다.

<br>

##### **Mark and Sweep**

- Mark: 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
- Sweep: Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업

 `Stop The World`를 통해 모든 작업을 중단시키면, GC는 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각이 어떤 객체를 참고하고 있는지를 탐색하게 된다. 그리고 사용되고 있는 메모리를 식별하는데, 이러한 과정을 Mark라고 한다. 이후에 Mark가 되지 않은 객체들을 메모리에서 제거하는데, 이러한 과정을 Sweep라고 한다.

<br>

##### Q. Old 영역이 가득 차면 Major GC가 발생하고 이로 인해 성능에 문제가 생긴다면 Old 영역의 Heap 크기를 키우면 되지 않을까??

​	A. Heap 영역을 키우더라도 결국 Major GC는 언젠가 발생하게 된다. 이때, Heap 영역의 크기에 비례해서 GC 실행 시간이 정해지므로 오히려 애플리케이션의 실행이 멈추는 시간이 더 길어지는 악효과가 발생한다.

​	--> Major GC 를 어떤 알고리즘을 이용해 어떻게 최소화 할 것인가. 어떻게 피할 것인가를 생각하자.

<br>

참고 : https://d2.naver.com/helloworld/1329