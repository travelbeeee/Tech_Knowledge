### 2) JVM ( Java Virtual Machine )

<img src="https://user-images.githubusercontent.com/59816811/122666182-c738be00-d1e6-11eb-9e85-7de121cc3f18.png" alt="image" style="width:500px" />

1) 실행될 클래스 파일을 메모리에 로드 후 초기화 작업 수행

2) 메소드와 클랜스변수들을 해당 메모리 영역에 배치

3) 클래스로드가 끝난 후 JVM은 main 메소드를 찾아 지역변수, 객체변수, 참조변수를 스택에 쌓음

4) 다음 라인을 진행하면서 상황에 맞는 작업 수행

- Class Loader : JVM 내로 클래스를 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈로써 런타임시 동적으로 클래스를 로드한다.
- Execution Engine : Class Loader를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트 코드를 실행한다. ( 자바 바이트 코드를 명령어 단위로 읽어서 실행한다. )
- Garbage Collector : JVM은 Garbage Collector를 통해 메모리 관리 기능을 자동으로 수행한다. 애플리케이션이 생성한 객체의 생존 여부를 판단하여 더 이상 사용되지 않는 객체를 해제하는 방식으로 메모리를 자동 관리한다.
- Runtime Data Area : JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. Class Loader에서 준비한 데이터들을 보관하는 저장소이다.

<img src="https://user-images.githubusercontent.com/59816811/122667065-dec67580-d1eb-11eb-8e49-7d110e556dec.png" alt="image" style="width:500px;" />

- Method (Static) Area : JVM이 읽어들인 클래스와 인터페이스에 대한 런타임 상수 풀, 멤버 변수(필드), 클래스 변수(static 변수), 생성자와 메소드를 저장하는 공간이다.
- Runtime Constant Pool : 클래스와 인터페이스 상수, 메소드와 필드에 대한 모든 레퍼런스를 저장하고 있어 JVM은 런타임 상수 풀을 통해 메소드나 필드의 실제 메모리 상 주소를 찾아 참조한다.
- Heap Area : JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역이다. New 연산자로 생성된 객체들을 저장한다.
- Stack Area : 각 쓰레드마다 하나씩 존재하며, 쓰레드가 시작될 때 할당되는 영역이다. 메소드를 호출할 때마다 프레임을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행한다. 기본타입 변수는 스택 영역에 직접 값을 가지고, 참조타입 변수는 힙 영역이나 메소드 영역의 객체 주소를 가지게 된다.
- PC Register : 현재 수행 중인 JVM 명령 주소를 가지고 있다. 연산 결과를 메모리에 전달하기 전에 저장하는 CPU 내의 기억 장치이다.
- Native Method Stack Area : 자바 외 언어로 작성된 네이티브 코드를 위한 Stack 영역이다.

OS 위에 존재하는 JVM 위에서 실행되기 때문에 운영체제에 독립적으로 실행될 수 있습니다. 하지만, JVM을 사용하기 때문에 많은 메모리를 사용하고 실행 속도가 느리다는 단점이 있습니다. 

실행하는 과정에서 JVM이 반드시 완벽하게 로딩되어야하기 때문에 프로그램의 초기 시작 시간이 C/C++에 비해 2~3배 정도 느리다고 알려져있습니다. 단적인 예로, 콘솔 화면에 달랑 "Hello, World"를 찍는 프로그램이 실행되는 데에도 AWT, Swing, SQL 같은 불필요한 기능까지 모두 로딩된 후에 실행되기 때문에 속도가 느릴 수 밖에 없습니다.

<br>

