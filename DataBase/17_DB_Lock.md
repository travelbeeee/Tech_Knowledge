# DB_Lock

 DB는 데이터를 영속적으로 저장하고 잘 관리하는 것이 목적인 시스템이다. 시스템의 데이터에 대해서 동시에 접근하는 경우가 생길 수 밖에 없고, 데이터가 오염되는 문제가 생길 수 있습니다. 이런 문제를 해결하기 위해 DBMS는 `Lock`이라는 방법을 사용합니다.

<br>

### 1) Lock

 **`Lock`이란 트랜잭션 처리의 순차성을 보장하고 데이터의 일관성을 보장하기 위한 방법**입니다. 

그리고 중요한 것은 DBMS마다 Lock을 구현하는 방식과 세부적인 방법이 다릅니다. 따라서 DBMS를 효과적으로 이용하기 위해서는 해당 DB의 Lock에 대한 이해가 요구됩니다.

<br>

### 2) Lock 종류

  `Lock`의 종류는 크게 `Shared Lock` 과 `Exclusive Lock`이 있습니다.

- `Shared Lock`

  `Shared Lock`은 `Lock`을 걸은 데이터에 대해서 다른 트랜젝션에서도 `Shared Lock`을 걸 수는 있지만, `Exclusive Lock`은 걸 수 없습니다.

   데이터를 읽을 때 사용해서 `Read Lock`이라고도 불립니다. `Shared Lock`이 걸려 있는 데이터를 다른 사람도 `Shared Lock`을 걸고 읽을 수 있습니다.

- `Exclusive Lock`

   `Exclusive Lock`은 `Lock`을 걸은 데이터에 대해 `Lock`이 해제되기 전까지는 다른 `Lock`을 설정할 수 없습니다.

   데이터를 변경할 때 사용하고 `Exclusive Lock`이 걸려 있는 데이터는 다른 곳에서 읽기와 쓰기가 불가능합니다.

<br>

### 3) Lock 레벨

- 데이터베이스

   전체 데이터베이스를 기준으로 Lock이 걸립니다. 1개의 세션만 하나의 데이터베이스의 데이터에 접근할 수 있어서 DB 전체에 영향이 있는 업데이트 같은 큰 작업에서만 사용하는 락입니다.

- 파일

  데이터베이스 파일을 기준으로 Lock이 걸립니다. 실제 데이터가 쓰여지는 물리적인 파일을 의미하고 파일 전체를 백업할 때 사용하는 락입니다.

- 테이블

   테이블을 기준으로 Lock이 걸립니다. 전체 테이블에 변경이 있을 경우 사용합니다. 테이블을 제어하는 `DDL` 구문을 사용할 때 걸리는 Lock입니다. 

- 페이지, 블럭

   파일을 구성하는 페이지 또는 블록을 기준으로 Lock이 걸립니다.

- Row

   Row 수준의 Lock이 걸립니다. 가장 많이 사용됩니다.

- Column

   Column 기준으로 Lock이 걸립니다. Lock 설정 및 해제시 리소스가 많이 들어서 잘 사용하지 않습니다.

<br>

### 4) Blocking

 `Blocking`은 `Lock` 의 경합이 발생하여 특정 `Transaction`이 작업을 진행시키지 못한 상태를 말합니다. `Race Condition`을 의미하고, `DeadLock`으로 발전할 수 있습니다. 뒤에 들어온 트랜젝션이 이전 트랜젝션에 의해 진행이 멈춘 상태를 의미합니다.

 경합이 자주 일어나면 성능에 문제가 있기 때문에, 경합 발생 위험을 낮춰야합니다.

- 트랜젝션의 단위를 짧게 해서 경합의 위험성을 낮춘다.
- 트랜젝션 `Isolation Level`을 불필요하게 엄격하게 설정하지 않습니다.
- `Lock TimeOut` 을 설정하여 해당 `Lock`의 최대 시간을 설정합니다.
- 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계합니다.

<br>

### 5) DeadLock

 `DeadLock`은 서로 다른 트랜젝션이 각각 `Lock`을 설정하고 서로의 `Lock` 에 접근하여 값을 얻어오려고 해 무한히 대기에 빠지는 상태를 말합니다.  DBMS에서는 보통 `DeadLock` 상황이 감지되면 하나의 트랜젝션을 강제로 종료시켜서 `DeadLock` 문제를 해결합니다. 

 `Shared Lock`과 `Exclusive Lock` 혹은 `Exclusive Lock`과 `Exclusive Lock`에서 발생합니다.

```sql
A 트랜젝션에서 1번 사원의 정보를 select --> S Lock
B 트랜젝션에서 1번 사원의 정보를 select --> S Lock
B 트랜젝션에서 1번 사원의 정보를 update --> A 트랜젝션에 의해 S Lock이 있으므로 X Lock 실패 --> Blocking
A 트랜젝션에서 1번 사원의 정보를 update --> B 트랜젝션에 의해 S Lock이 있으므로 X Lock 실패 --> Blocking
--> 데드락 상황 발생 --> Timeout으로 실패 후 데이터는 원래대로 남아있게 된다.
```

<br>

### Q. MySQL에서는 어떻게 동작할까?

 MySQL은 5개의 row를 Updatae할 때 각 row에 대해서 update시 `Exclusive Lock`을 겁니다. 그리고, 모든 트랜젝션이 마무리되면 `Lock`을 해제합니다. 또, 데드락으로 감지되면 2개의 트랜젝션 중 데이터 변화가 적은 트랜젝션을 `Rollback` 시켜 데드락을 해소시킵니다.

<br>

### Q. 치킨 할인 쿠폰 선착순 1000매 이벤트를 진행하려고 한다. 어떻게 설계 할 것인가??

  DB Lock을 이용해서 구현하면 된다....?