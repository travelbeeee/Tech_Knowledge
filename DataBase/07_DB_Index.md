# DB_Index

### 1) Index란

 Index는 색인 또는 목차를 의미하는 단어로, 우리가 책에서 찾고자하는 정보가 담긴 페이지를 빠르게 찾을 때 주로 사용한다.

 마찬가지로, DB에서의 Index도 테이블에서 원하는 정보를 빠르게 찾을 때 사용하는 자료구조이다. 자주 검색하는 테이블의 Column 정보를 인덱스로 만들어두어, 조회를 할 때 더 빠르게 조회를 할 수 있게 하는 원리이다.

 즉, 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키는 자료구조이다.

 테이블에는 데이터들이 내부적으로 순서가 없이 뒤죽박죽 저장되고 실제로 물리적인 메모리에도 흩어져서 저장됩니다. 인덱스는 책의 목차처럼 데이터들을 정렬해서 관리하고 있습니다. 따라서, 조건에 맞는 데이터들을 빠르게 찾아낼 수 있습니다. 

 인덱스를 이용하면 Order by 에 의한 Sort 과정을 피할 수 있습니다. Order by는 굉장히 부하가 많이 걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고, 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생합니다. 인덱스를 사용한다면 이미 정렬이 되어 있기 때문에 이런 부하를 막을 수 있습니다.

 또한, 인덱스를 이용하면 MIN, MAX 값을 빠르게 찾을 수 있습니다.

<br>

### 2) Index의 관리

 DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있습니다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.

- INSERT : 새로운 데이터에 대한 인덱스를 추가해야한다.
- DELETE : 삭제하는 데이터에 대한 인덱스 정보를 갱신해야한다.
  - 이때, 인덱스는 실제로 삭제되는 것이 아니라, 사용하지 않는다고 표시만 한다. 따라서, 메모리 낭비가 발생한다.
- UPDATE : 수정하는 데이터에 대한 인덱스 정보를 갱신해야한다.
  - 인덱스가 실제로 갱신되는 것이 아니라, 기존의 인덱스를 삭제하고 갱신된 정보에 대한 새로운 인덱스가 추가된다.
  - 인덱스를 구성하는 컬럼 이외의 데이터가 Update되면 인덱스로 인한 부하가 발생하지 않는다.

<br>

### 3) Index의 장점 및 단점

 사용자가 디스크로부터 데이터를 가져와야할 때, 기본적으로 `Full Table Scan` 원리로 작동하게 된다.  100만, 1000만개의 데이터를 모두 순회하며 데이터를 찾게 되고 이는 비효율적이고 굉장히 오랜 시간이 걸리는 작업입니다. 따라서, 자주 찾는 데이터는 Index를 만들어 관리하면 조회를 빠르게 할 수 있고 보통 데이터를 삽입, 수정, 삭제하는 작업보다 조회하는 작업이 더 빈번하게 발생하므로 이점이 생깁니다.

 하지만, INSERT, DELETE, UPDATE 쿼리는 인덱스를 사용해서 오히려 추가 작업과 메모리 낭비가 생기게 됩니다. 또, SELECT 쿼리로 전체 데이터를 다 불러오는 경우에는 INDEX가 당연히 도움이 되지 않는다. 그리고 Index 기준 Column 이외의 조건에 해당되는 데이터를 찾아야된다면 마찬가지로 Index가 도움이 되지 않는다.

 따라서, 상황에 맞춰서 **Index에 따른 오버헤드 vs Index를 만들어서 생기는 이점** 을 비교하고 판단해야한다.

 **무조건, Index 를 만드는 것이 옳은 것은 아니다.**  오히려 `Full Table Scan`이 더 빠를 수도 있다. 

<br>

### 4) Index 생성 전략

 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 Index 테이블이 생성됩니다. 따라서, 생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한 넓고, 조건절에 호출 빈도는 잦은 컬럼을 인덱스로 사용하는 것이 좋습니다. 또한, 기준 컬럼을 최대한 중복이 되지 않는 값이 좋습니다. 즉, 정보를 잘게 세분화할 수 있는 Column을 기준으로 삼는 것이 좋다.

- 조건절에 자주 등장하는 컬럼
- 항상 = 으로 비교되는 컬럼
- 중복되는 데이터가 최소한인 컬럼
- Order by 절에서 자주 사용되는 컬럼

<br>

### 5) Index 구조와 원리

 Index에서 가장 많이 사용되는 구조는 B-Tree 자료구조 ( Balanced Tree ) 입니다. B-Tree 는 이름 그대로 스스로 균형을 맞추는 Tree 자료 구조 입니다. Binary Search Tree와 유사하지만 한 노드 당 자식 노드가 2개 이상 가능합니다. 최악의 경우에도 O(logN) 검색 성능을 보이기 때문에 Index에서 사용하고 있습니다.

![다운로드](https://user-images.githubusercontent.com/59816811/135718810-c92fc6d8-3334-40e3-995b-5e0b6f9f679c.png)

 가장 상단의 노드를 'Root Node', 중간 노드들을 'Branch Node', 가장 아래 노드를 'Leaf Node' 라고 합니다.

![그림5](https://user-images.githubusercontent.com/59816811/131294135-b15d805c-ea32-4cea-94d0-3e1da0b9750f.png)

 Mysql InnoDB 엔진에서는 B-Tree를 확장한 B+Tree 자료구조를 내부적으로 이용하고, Oracle 에서는 B*Tree 자료구조를 가장 많이 이용합니다.

<br>

### 6)  B+ Tree 자료 구조

 B+Tree는 B-Tree의 변형구조로 Index 부분과 Leaf node로 구성된 순차 data 부분으로 이루어집니다.  Leaf Node를 제외한 Root Node와 Branch Node는 다음 Node 위치 정보를 가지고 있고, Data 정보는 가지고 있지 않습니다. Leaf Node에는 레코드 정보가 담겨있습니다. 또, Leaf Node끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리합니다. 다만, B+Tree는 Leaf Node까지 무조건 탐색을 진행해야한다는 단점이 있습니다.

<br>

### 7) B* Tree 자료 구조

 B* Tree 자료 구조는 B-Tree 자료 구조를 확장한 것으로 분열, 합병 연산이 빈번하게 발생하며 Node 수가 증가하는 B-Tree의 단점을 보완한 자료구조 입니다. 간단하게 정리하면 각 노드를 (2/3) 이상 씩 최대한 채워서 사용하는 자료구조 입니다. 

<br>

> 참고한 블로그
>
> https://beelee.tistory.com/37
>
> https://mangkyu.tistory.com/96