# Transaction

### 1) Transaction 이란

 트랜잭션이란 질의(query)를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 **Rollback**을 수행하고, 오류없이 실행을 마치면 **commit**을 하는 실행 단위를 의미합니다. 즉, 한 번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는 **작업수행의 논리적 단위**입니다.

 DBMS의 성능은 초당 트랜잭션의 실행 수로 측정하는만큼 DB에서 기본이 되는 작업 단위입니다.

 트랜잭션은 DB 서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 **데이터 부정합을 방지**하고자 할 때 사용합니다. 부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리하도록 하면 되는데, 이는 효율이 너무 떨어집니다. 즉, 병렬로 처리할 수 밖에 없는 현실적인 상황으로 인해 부정합을 방지하고자 트랜잭션을 사용하는 것입니다.

<br>

### 2) Transaction ACID

 트잭션은 ACID 라고 불리는 4가지 특성이 있습니다.

- ###### Atomicity ( 원자성 )
  
  - 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것을 말합니다.
  - 즉, All or Noting의 개념으로서 작업 단위를 일부분만 실행하지 않는다는 것을 의미합니다.
  - 송금하는 사람의 계좌에서 돈은 빠져나갔는데 받는 사람의 계좌에 돈이 들어오지 않는 일은 없어야 한다.
- ###### Consistency ( 일관성 )
  
  - 트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지하는 것, 여러 제약 조건에 맞는 상태를 보장하는 것을 말합니다.
  - 송금하는 사람의 계좌 잔고가 String으로 바뀌거나 0보다 작아지는 등의 문제가 발생하지 않는 것을 말합니다.
- ###### Isolation ( 격리성 )
  
  - 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것을 말합니다.
  - 즉, 트랜잭션끼리는 서로를 간섭할 수 없습니다.
  - 송금하는 사람의 계좌에서 돈은 빠져나갔는데 받는 사람의 계좌에 돈이 아직 들어가지 않은 DB 상황을 다른 transaction이 읽으면 안 된다.
- ###### Durability ( 지속성 )
  
  - 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 말합니다.
  - Commit을 하면 현재 상태는 영원히 보장됩니다.
  -  한 번 송금이 성공하면 은행 시스템에 장애가 발생하더라도 송금이 성공한 상태로 복구할 수 있어야 한다.

<br>

### 3) Atomicity ( 원자성 ) 보장

 트랜잭션에서 원자성을 보장하기 위해 수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하면서, 이전에 commit된 상태를 임시 영역에 따로 저장합니다. 즉, 현재 수행하고 있는 트랜잭션에서 오류가 발생하면 현재 내역을 날려버리고 임시 영역에 저장했던 상태로 rollback 합니다.

 이런 임시영역을 Rollback 세그먼트 또는 Undo 영역이라고 부릅니다.

 오류가 발생하면 rollback을 하는데, 확실하게 오류가 발생하지 않는 부분도 다시 처음부터 작업을 수행해야 합니다. 따라서 확실한 부분에 대해서는 rollback이 되지 않도록 중간 저장 지점인 save point를 지정할 수 있습니다. save point를 지정하면 rollback 할 때 save point 이전은 확실하다 간주하고 그 이후부터 진행하게 됩니다.

> Rollback Segment 는 Oracle 9i 이전 버전, Undo 영역은 Oracle 9i 이후 버전에서 같은 영역을 얘기하는 명칭이다.

<br>

### 4) Consistency ( 일관성 ) 보장

  어떤 이벤트와 조건이 발생했을 때, 데이터베이스 시스템이 자동적으로 수행할 동작을 명시하는 트리거( Trigger )를 통해 보장합니다. 예를 들어, 한쪽 DB의 A 테이블에 정보의 수정이 일어났을 경우 다른 쪽 DB의 A테이블에도 함께 수정될 수 있도록 명시적으로 자동 업데이트를 하는 명령을 구성할 수도 있습니다.

<br>

### 5) Isolation ( 격리성 ) 보장

   데이터를 읽거나 쓰기 작업 중일때는 해당 영역에 Lock을 걸어서 다른 트랜잭션이 접근하지 못하도록 하고, 먼저 들어온 트랜잭션 요청이 끝나면 UnLock 하여 다른 트랜잭션이 처리될 수 있도록 허용하는 방식을 통해 격리성을 보장합니다.

 <br>

### 6) Transaction 상태

 ![transaction-status](https://user-images.githubusercontent.com/59816811/136233916-16f48634-9236-44c1-93d6-9aea40b8e0ee.png)

- Active

  트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.

- Failed

  트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.

- Partially Committed

  트랜잭션의 `Commit` 명령이 도착한 상태. 트랜잭션의 `commit`이전 `sql`문이 수행되고 `commit`만 남은 상태를 말한다.

- Committed

  트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.

- Aborted

  트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.

<br>

###### Partially Committed 와 Committed 의 차이점

`Commit` 요청이 들어오면 상태는 `Partial Commited` 상태가 된다. 이후 `Commit`을 문제없이 수행할 수 있으면 `Committed` 상태로 전이되고, 만약 오류가 발생하면 `Failed` 상태가 된다. 즉, `Partial Commited`는 `Commit` 요청이 들어왔을때를 말하며, `Commited`는 `Commit`을 정상적으로 완료한 상태를 말한다.

<br>

### 7) Transaction 주의점

 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화하라는 의미다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.

<br>
